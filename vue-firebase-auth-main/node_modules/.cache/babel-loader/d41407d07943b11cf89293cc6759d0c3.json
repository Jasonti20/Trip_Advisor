{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nvar _excluded = [\"prefixCls\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readonly\", \"keyboard\", \"controls\", \"autofocus\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"lazy\", \"class\", \"style\"];\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport getMiniDecimal, { toFixed } from './utils/MiniDecimal';\nimport StepHandler from './StepHandler';\nimport { getNumberPrecision, num2str, validateNumber } from './utils/numberUtil';\nimport useCursor from './hooks/useCursor';\nimport useFrame from './hooks/useFrame';\nimport { watch, computed, ref, defineComponent } from 'vue';\nimport KeyCode from '../../_util/KeyCode';\nimport classNames from '../../_util/classNames';\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\n\nvar getDecimalValue = function getDecimalValue(stringMode, decimalValue) {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n\n  return decimalValue.toNumber();\n};\n\nvar getDecimalIfValidate = function getDecimalIfValidate(value) {\n  var decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\n\nexport var inputNumberProps = function inputNumberProps() {\n  return {\n    /** value will show as string */\n    stringMode: {\n      type: Boolean\n    },\n    defaultValue: {\n      type: [String, Number]\n    },\n    value: {\n      type: [String, Number]\n    },\n    prefixCls: {\n      type: String\n    },\n    min: {\n      type: [String, Number]\n    },\n    max: {\n      type: [String, Number]\n    },\n    step: {\n      type: [String, Number],\n      default: 1\n    },\n    tabindex: {\n      type: Number\n    },\n    controls: {\n      type: Boolean,\n      default: true\n    },\n    readonly: {\n      type: Boolean\n    },\n    disabled: {\n      type: Boolean\n    },\n    autofocus: {\n      type: Boolean\n    },\n    keyboard: {\n      type: Boolean,\n      default: true\n    },\n\n    /** Parse display value to validate number */\n    parser: {\n      type: Function\n    },\n\n    /** Transform `value` to display value show in input */\n    formatter: {\n      type: Function\n    },\n\n    /** Syntactic sugar of `formatter`. Config precision of display. */\n    precision: {\n      type: Number\n    },\n\n    /** Syntactic sugar of `formatter`. Config decimal separator of display. */\n    decimalSeparator: {\n      type: String\n    },\n    onInput: {\n      type: Function\n    },\n    onChange: {\n      type: Function\n    },\n    onPressEnter: {\n      type: Function\n    },\n    onStep: {\n      type: Function\n    },\n    onBlur: {\n      type: Function\n    },\n    onFocus: {\n      type: Function\n    }\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'InnerInputNumber',\n  inheritAttrs: false,\n  props: _objectSpread(_objectSpread({}, inputNumberProps()), {}, {\n    lazy: Boolean\n  }),\n  slots: ['upHandler', 'downHandler'],\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n        slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var inputRef = ref();\n    var focus = ref(false);\n    var userTypingRef = ref(false);\n    var compositionRef = ref(false);\n    var decimalValue = ref(getMiniDecimal(props.value));\n\n    function setUncontrolledDecimalValue(newDecimal) {\n      if (props.value === undefined) {\n        decimalValue.value = newDecimal;\n      }\n    } // ====================== Parser & Formatter ======================\n\n    /**\n     * `precision` is used for formatter & onChange.\n     * It will auto generate by `value` & `step`.\n     * But it will not block user typing.\n     *\n     * Note: Auto generate `precision` is used for legacy logic.\n     * We should remove this since we already support high precision with BigInt.\n     *\n     * @param number  Provide which number should calculate precision\n     * @param userTyping  Change by user typing\n     */\n\n\n    var getPrecision = function getPrecision(numStr, userTyping) {\n      if (userTyping) {\n        return undefined;\n      }\n\n      if (props.precision >= 0) {\n        return props.precision;\n      }\n\n      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props.step));\n    }; // >>> Parser\n\n\n    var mergedParser = function mergedParser(num) {\n      var numStr = String(num);\n\n      if (props.parser) {\n        return props.parser(numStr);\n      }\n\n      var parsedStr = numStr;\n\n      if (props.decimalSeparator) {\n        parsedStr = parsedStr.replace(props.decimalSeparator, '.');\n      } // [Legacy] We still support auto convert `$ 123,456` to `123456`\n\n\n      return parsedStr.replace(/[^\\w.-]+/g, '');\n    }; // >>> Formatter\n\n\n    var inputValue = ref('');\n\n    var mergedFormatter = function mergedFormatter(number, userTyping) {\n      if (props.formatter) {\n        return props.formatter(number, {\n          userTyping: userTyping,\n          input: String(inputValue.value)\n        });\n      }\n\n      var str = typeof number === 'number' ? num2str(number) : number; // User typing will not auto format with precision directly\n\n      if (!userTyping) {\n        var mergedPrecision = getPrecision(str, userTyping);\n\n        if (validateNumber(str) && (props.decimalSeparator || mergedPrecision >= 0)) {\n          // Separator\n          var separatorStr = props.decimalSeparator || '.';\n          str = toFixed(str, separatorStr, mergedPrecision);\n        }\n      }\n\n      return str;\n    }; // ========================== InputValue ==========================\n\n    /**\n     * Input text value control\n     *\n     * User can not update input content directly. It update with follow rules by priority:\n     *  1. controlled `value` changed\n     *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n     *  2. User typing with format (not precision)\n     *  3. Blur or Enter trigger revalidate\n     */\n\n\n    var initValue = function () {\n      var initValue = props.value;\n\n      if (decimalValue.value.isInvalidate() && ['string', 'number'].includes(_typeof(initValue))) {\n        return Number.isNaN(initValue) ? '' : initValue;\n      }\n\n      return mergedFormatter(decimalValue.value.toString(), false);\n    }();\n\n    inputValue.value = initValue; // Should always be string\n\n    function setInputValue(newValue, userTyping) {\n      inputValue.value = mergedFormatter( // Invalidate number is sometime passed by external control, we should let it go\n      // Otherwise is controlled by internal interactive logic which check by userTyping\n      // You can ref 'show limited value when input is not focused' test for more info.\n      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);\n    } // >>> Max & Min limit\n\n\n    var maxDecimal = computed(function () {\n      return getDecimalIfValidate(props.max);\n    });\n    var minDecimal = computed(function () {\n      return getDecimalIfValidate(props.min);\n    });\n    var upDisabled = computed(function () {\n      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n\n      return maxDecimal.value.lessEquals(decimalValue.value);\n    });\n    var downDisabled = computed(function () {\n      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n\n      return decimalValue.value.lessEquals(minDecimal.value);\n    }); // Cursor controller\n\n    var _useCursor = useCursor(inputRef, focus),\n        _useCursor2 = _slicedToArray(_useCursor, 2),\n        recordCursor = _useCursor2[0],\n        restoreCursor = _useCursor2[1]; // ============================= Data =============================\n\n    /**\n     * Find target value closet within range.\n     * e.g. [11, 28]:\n     *    3  => 11\n     *    23 => 23\n     *    99 => 28\n     */\n\n\n    var getRangeValue = function getRangeValue(target) {\n      // target > max\n      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {\n        return maxDecimal.value;\n      } // target < min\n\n\n      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {\n        return minDecimal.value;\n      }\n\n      return null;\n    };\n    /**\n     * Check value is in [min, max] range\n     */\n\n\n    var isInRange = function isInRange(target) {\n      return !getRangeValue(target);\n    };\n    /**\n     * Trigger `onChange` if value validated and not equals of origin.\n     * Return the value that re-align in range.\n     */\n\n\n    var triggerValueUpdate = function triggerValueUpdate(newValue, userTyping) {\n      var updateValue = newValue;\n      var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty(); // Skip align value when trigger value is empty.\n      // We just trigger onChange(null)\n      // This should not block user typing\n\n      if (!updateValue.isEmpty() && !userTyping) {\n        // Revert value in range if needed\n        updateValue = getRangeValue(updateValue) || updateValue;\n        isRangeValidate = true;\n      }\n\n      if (!props.readonly && !props.disabled && isRangeValidate) {\n        var numStr = updateValue.toString();\n        var mergedPrecision = getPrecision(numStr, userTyping);\n\n        if (mergedPrecision >= 0) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n        } // Trigger event\n\n\n        if (!updateValue.equals(decimalValue.value)) {\n          var _props$onChange;\n\n          setUncontrolledDecimalValue(updateValue);\n          (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, updateValue.isEmpty() ? null : getDecimalValue(props.stringMode, updateValue)); // Reformat input if value is not controlled\n\n          if (props.value === undefined) {\n            setInputValue(updateValue, userTyping);\n          }\n        }\n\n        return updateValue;\n      }\n\n      return decimalValue.value;\n    }; // ========================== User Input ==========================\n\n\n    var onNextPromise = useFrame(); // >>> Collect input value\n\n    var collectInputValue = function collectInputValue(inputStr) {\n      var _props$onInput;\n\n      recordCursor(); // Update inputValue incase input can not parse as number\n\n      inputValue.value = inputStr; // Parse number\n\n      if (!compositionRef.value) {\n        var finalValue = mergedParser(inputStr);\n        var finalDecimal = getMiniDecimal(finalValue);\n\n        if (!finalDecimal.isNaN()) {\n          triggerValueUpdate(finalDecimal, true);\n        }\n      } // Trigger onInput later to let user customize value if they want do handle something after onChange\n\n\n      (_props$onInput = props.onInput) === null || _props$onInput === void 0 ? void 0 : _props$onInput.call(props, inputStr); // optimize for chinese input experience\n      // https://github.com/ant-design/ant-design/issues/8196\n\n      onNextPromise(function () {\n        var nextInputStr = inputStr;\n\n        if (!props.parser) {\n          nextInputStr = inputStr.replace(/。/g, '.');\n        }\n\n        if (nextInputStr !== inputStr) {\n          collectInputValue(nextInputStr);\n        }\n      });\n    }; // >>> Composition\n\n\n    var onCompositionStart = function onCompositionStart() {\n      compositionRef.value = true;\n    };\n\n    var onCompositionEnd = function onCompositionEnd() {\n      compositionRef.value = false;\n      collectInputValue(inputRef.value.value);\n    }; // >>> Input\n\n\n    var onInternalInput = function onInternalInput(e) {\n      collectInputValue(e.target.value);\n    }; // ============================= Step =============================\n\n\n    var onInternalStep = function onInternalStep(up) {\n      var _props$onStep, _inputRef$value; // Ignore step since out of range\n\n\n      if (up && upDisabled.value || !up && downDisabled.value) {\n        return;\n      } // Clear typing status since it may caused by up & down key.\n      // We should sync with input value.\n\n\n      userTypingRef.value = false;\n      var stepDecimal = getMiniDecimal(props.step);\n\n      if (!up) {\n        stepDecimal = stepDecimal.negate();\n      }\n\n      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());\n      var updatedValue = triggerValueUpdate(target, false);\n      (_props$onStep = props.onStep) === null || _props$onStep === void 0 ? void 0 : _props$onStep.call(props, getDecimalValue(props.stringMode, updatedValue), {\n        offset: props.step,\n        type: up ? 'up' : 'down'\n      });\n      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();\n    }; // ============================ Flush =============================\n\n    /**\n     * Flush current input content to trigger value change & re-formatter input if needed\n     */\n\n\n    var flushInputValue = function flushInputValue(userTyping) {\n      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      var formatValue = parsedValue;\n\n      if (!parsedValue.isNaN()) {\n        // Only validate value or empty value can be re-fill to inputValue\n        // Reassign the formatValue within ranged of trigger control\n        formatValue = triggerValueUpdate(parsedValue, userTyping);\n      } else {\n        formatValue = decimalValue.value;\n      }\n\n      if (props.value !== undefined) {\n        // Reset back with controlled value first\n        setInputValue(decimalValue.value, false);\n      } else if (!formatValue.isNaN()) {\n        // Reset input back since no validate value\n        setInputValue(formatValue, false);\n      }\n    };\n\n    var onKeyDown = function onKeyDown(event) {\n      var which = event.which;\n      userTypingRef.value = true;\n\n      if (which === KeyCode.ENTER) {\n        var _props$onPressEnter;\n\n        if (!compositionRef.value) {\n          userTypingRef.value = false;\n        }\n\n        flushInputValue(false);\n        (_props$onPressEnter = props.onPressEnter) === null || _props$onPressEnter === void 0 ? void 0 : _props$onPressEnter.call(props, event);\n      }\n\n      if (props.keyboard === false) {\n        return;\n      } // Do step\n\n\n      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {\n        onInternalStep(KeyCode.UP === which);\n        event.preventDefault();\n      }\n    };\n\n    var onKeyUp = function onKeyUp() {\n      userTypingRef.value = false;\n    }; // >>> Focus & Blur\n\n\n    var onBlur = function onBlur(e) {\n      flushInputValue(false);\n      focus.value = false;\n      userTypingRef.value = false;\n      emit('blur', e);\n    }; // ========================== Controlled ==========================\n    // Input by precision\n\n\n    watch(function () {\n      return props.precision;\n    }, function () {\n      if (!decimalValue.value.isInvalidate()) {\n        setInputValue(decimalValue.value, false);\n      }\n    }, {\n      flush: 'post'\n    }); // Input by value\n\n    watch(function () {\n      return props.value;\n    }, function () {\n      var newValue = getMiniDecimal(props.value);\n      decimalValue.value = newValue;\n      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value)); // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n      // But let it go if user set `formatter`\n\n      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props.formatter) {\n        // Update value as effect\n        setInputValue(newValue, userTypingRef.value);\n      }\n    }, {\n      flush: 'post'\n    }); // ============================ Cursor ============================\n\n    watch(inputValue, function () {\n      if (props.formatter) {\n        restoreCursor();\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(function () {\n      return props.disabled;\n    }, function (val) {\n      if (val) {\n        focus.value = false;\n      }\n    });\n    expose({\n      focus: function focus() {\n        var _inputRef$value2;\n\n        (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.focus();\n      },\n      blur: function blur() {\n        var _inputRef$value3;\n\n        (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.blur();\n      }\n    });\n    return function () {\n      var _classNames;\n\n      var _attrs$props = _objectSpread(_objectSpread({}, attrs), props),\n          _attrs$props$prefixCl = _attrs$props.prefixCls,\n          prefixCls = _attrs$props$prefixCl === void 0 ? 'rc-input-number' : _attrs$props$prefixCl,\n          min = _attrs$props.min,\n          max = _attrs$props.max,\n          _attrs$props$step = _attrs$props.step,\n          step = _attrs$props$step === void 0 ? 1 : _attrs$props$step,\n          defaultValue = _attrs$props.defaultValue,\n          value = _attrs$props.value,\n          disabled = _attrs$props.disabled,\n          readonly = _attrs$props.readonly,\n          keyboard = _attrs$props.keyboard,\n          _attrs$props$controls = _attrs$props.controls,\n          controls = _attrs$props$controls === void 0 ? true : _attrs$props$controls,\n          autofocus = _attrs$props.autofocus,\n          stringMode = _attrs$props.stringMode,\n          parser = _attrs$props.parser,\n          formatter = _attrs$props.formatter,\n          precision = _attrs$props.precision,\n          decimalSeparator = _attrs$props.decimalSeparator,\n          onChange = _attrs$props.onChange,\n          onInput = _attrs$props.onInput,\n          onPressEnter = _attrs$props.onPressEnter,\n          onStep = _attrs$props.onStep,\n          lazy = _attrs$props.lazy,\n          className = _attrs$props.class,\n          style = _attrs$props.style,\n          inputProps = _objectWithoutProperties(_attrs$props, _excluded);\n\n      var upHandler = slots.upHandler,\n          downHandler = slots.downHandler;\n      var inputClassName = \"\".concat(prefixCls, \"-input\");\n      var eventProps = {};\n\n      if (lazy) {\n        eventProps.onChange = onInternalInput;\n      } else {\n        eventProps.onInput = onInternalInput;\n      }\n\n      return _createVNode(\"div\", {\n        \"class\": classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-focused\"), focus.value), _defineProperty(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefixCls, \"-readonly\"), readonly), _defineProperty(_classNames, \"\".concat(prefixCls, \"-not-a-number\"), decimalValue.value.isNaN()), _defineProperty(_classNames, \"\".concat(prefixCls, \"-out-of-range\"), !decimalValue.value.isInvalidate() && !isInRange(decimalValue.value)), _classNames)),\n        \"style\": style,\n        \"onKeydown\": onKeyDown,\n        \"onKeyup\": onKeyUp\n      }, [controls && _createVNode(StepHandler, {\n        \"prefixCls\": prefixCls,\n        \"upDisabled\": upDisabled.value,\n        \"downDisabled\": downDisabled.value,\n        \"onStep\": onInternalStep\n      }, {\n        upNode: upHandler,\n        downNode: downHandler\n      }), _createVNode(\"div\", {\n        \"class\": \"\".concat(inputClassName, \"-wrap\")\n      }, [_createVNode(\"input\", _objectSpread(_objectSpread(_objectSpread({\n        \"autofocus\": autofocus,\n        \"autocomplete\": \"off\",\n        \"role\": \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),\n        \"step\": step\n      }, inputProps), {}, {\n        \"ref\": inputRef,\n        \"class\": inputClassName,\n        \"value\": inputValue.value,\n        \"disabled\": disabled,\n        \"readonly\": readonly,\n        \"onFocus\": function onFocus(e) {\n          focus.value = true;\n          emit('focus', e);\n        }\n      }, eventProps), {}, {\n        \"onBlur\": onBlur,\n        \"onCompositionstart\": onCompositionStart,\n        \"onCompositionend\": onCompositionEnd\n      }), null)])]);\n    };\n  }\n});","map":{"version":3,"names":["_defineProperty","_objectWithoutProperties","_slicedToArray","_typeof","_objectSpread","_excluded","createVNode","_createVNode","resolveDirective","_resolveDirective","getMiniDecimal","toFixed","StepHandler","getNumberPrecision","num2str","validateNumber","useCursor","useFrame","watch","computed","ref","defineComponent","KeyCode","classNames","getDecimalValue","stringMode","decimalValue","isEmpty","toString","toNumber","getDecimalIfValidate","value","decimal","isInvalidate","inputNumberProps","type","Boolean","defaultValue","String","Number","prefixCls","min","max","step","default","tabindex","controls","readonly","disabled","autofocus","keyboard","parser","Function","formatter","precision","decimalSeparator","onInput","onChange","onPressEnter","onStep","onBlur","onFocus","compatConfig","MODE","name","inheritAttrs","props","lazy","slots","setup","_ref","attrs","emit","expose","inputRef","focus","userTypingRef","compositionRef","setUncontrolledDecimalValue","newDecimal","undefined","getPrecision","numStr","userTyping","Math","mergedParser","num","parsedStr","replace","inputValue","mergedFormatter","number","input","str","mergedPrecision","separatorStr","initValue","includes","isNaN","setInputValue","newValue","maxDecimal","minDecimal","upDisabled","lessEquals","downDisabled","_useCursor","_useCursor2","recordCursor","restoreCursor","getRangeValue","target","isInRange","triggerValueUpdate","updateValue","isRangeValidate","equals","_props$onChange","call","onNextPromise","collectInputValue","inputStr","_props$onInput","finalValue","finalDecimal","nextInputStr","onCompositionStart","onCompositionEnd","onInternalInput","e","onInternalStep","up","_props$onStep","_inputRef$value","stepDecimal","negate","add","updatedValue","offset","flushInputValue","parsedValue","formatValue","onKeyDown","event","which","ENTER","_props$onPressEnter","UP","DOWN","preventDefault","onKeyUp","flush","currentParsedValue","val","_inputRef$value2","blur","_inputRef$value3","_classNames","_attrs$props","_attrs$props$prefixCl","_attrs$props$step","_attrs$props$controls","className","class","style","inputProps","upHandler","downHandler","inputClassName","concat","eventProps","upNode","downNode"],"sources":["/Users/jasonti/Desktop/Tripper/vue/node_modules/ant-design-vue/es/input-number/src/InputNumber.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nvar _excluded = [\"prefixCls\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readonly\", \"keyboard\", \"controls\", \"autofocus\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"lazy\", \"class\", \"style\"];\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport getMiniDecimal, { toFixed } from './utils/MiniDecimal';\nimport StepHandler from './StepHandler';\nimport { getNumberPrecision, num2str, validateNumber } from './utils/numberUtil';\nimport useCursor from './hooks/useCursor';\nimport useFrame from './hooks/useFrame';\nimport { watch, computed, ref, defineComponent } from 'vue';\nimport KeyCode from '../../_util/KeyCode';\nimport classNames from '../../_util/classNames';\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nvar getDecimalValue = function getDecimalValue(stringMode, decimalValue) {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nvar getDecimalIfValidate = function getDecimalIfValidate(value) {\n  var decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nexport var inputNumberProps = function inputNumberProps() {\n  return {\n    /** value will show as string */\n    stringMode: {\n      type: Boolean\n    },\n    defaultValue: {\n      type: [String, Number]\n    },\n    value: {\n      type: [String, Number]\n    },\n    prefixCls: {\n      type: String\n    },\n    min: {\n      type: [String, Number]\n    },\n    max: {\n      type: [String, Number]\n    },\n    step: {\n      type: [String, Number],\n      default: 1\n    },\n    tabindex: {\n      type: Number\n    },\n    controls: {\n      type: Boolean,\n      default: true\n    },\n    readonly: {\n      type: Boolean\n    },\n    disabled: {\n      type: Boolean\n    },\n    autofocus: {\n      type: Boolean\n    },\n    keyboard: {\n      type: Boolean,\n      default: true\n    },\n    /** Parse display value to validate number */\n    parser: {\n      type: Function\n    },\n    /** Transform `value` to display value show in input */\n    formatter: {\n      type: Function\n    },\n    /** Syntactic sugar of `formatter`. Config precision of display. */\n    precision: {\n      type: Number\n    },\n    /** Syntactic sugar of `formatter`. Config decimal separator of display. */\n    decimalSeparator: {\n      type: String\n    },\n    onInput: {\n      type: Function\n    },\n    onChange: {\n      type: Function\n    },\n    onPressEnter: {\n      type: Function\n    },\n    onStep: {\n      type: Function\n    },\n    onBlur: {\n      type: Function\n    },\n    onFocus: {\n      type: Function\n    }\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'InnerInputNumber',\n  inheritAttrs: false,\n  props: _objectSpread(_objectSpread({}, inputNumberProps()), {}, {\n    lazy: Boolean\n  }),\n  slots: ['upHandler', 'downHandler'],\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var inputRef = ref();\n    var focus = ref(false);\n    var userTypingRef = ref(false);\n    var compositionRef = ref(false);\n    var decimalValue = ref(getMiniDecimal(props.value));\n    function setUncontrolledDecimalValue(newDecimal) {\n      if (props.value === undefined) {\n        decimalValue.value = newDecimal;\n      }\n    }\n    // ====================== Parser & Formatter ======================\n    /**\n     * `precision` is used for formatter & onChange.\n     * It will auto generate by `value` & `step`.\n     * But it will not block user typing.\n     *\n     * Note: Auto generate `precision` is used for legacy logic.\n     * We should remove this since we already support high precision with BigInt.\n     *\n     * @param number  Provide which number should calculate precision\n     * @param userTyping  Change by user typing\n     */\n    var getPrecision = function getPrecision(numStr, userTyping) {\n      if (userTyping) {\n        return undefined;\n      }\n      if (props.precision >= 0) {\n        return props.precision;\n      }\n      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props.step));\n    };\n    // >>> Parser\n    var mergedParser = function mergedParser(num) {\n      var numStr = String(num);\n      if (props.parser) {\n        return props.parser(numStr);\n      }\n      var parsedStr = numStr;\n      if (props.decimalSeparator) {\n        parsedStr = parsedStr.replace(props.decimalSeparator, '.');\n      }\n      // [Legacy] We still support auto convert `$ 123,456` to `123456`\n      return parsedStr.replace(/[^\\w.-]+/g, '');\n    };\n    // >>> Formatter\n    var inputValue = ref('');\n    var mergedFormatter = function mergedFormatter(number, userTyping) {\n      if (props.formatter) {\n        return props.formatter(number, {\n          userTyping: userTyping,\n          input: String(inputValue.value)\n        });\n      }\n      var str = typeof number === 'number' ? num2str(number) : number;\n      // User typing will not auto format with precision directly\n      if (!userTyping) {\n        var mergedPrecision = getPrecision(str, userTyping);\n        if (validateNumber(str) && (props.decimalSeparator || mergedPrecision >= 0)) {\n          // Separator\n          var separatorStr = props.decimalSeparator || '.';\n          str = toFixed(str, separatorStr, mergedPrecision);\n        }\n      }\n      return str;\n    };\n    // ========================== InputValue ==========================\n    /**\n     * Input text value control\n     *\n     * User can not update input content directly. It update with follow rules by priority:\n     *  1. controlled `value` changed\n     *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n     *  2. User typing with format (not precision)\n     *  3. Blur or Enter trigger revalidate\n     */\n    var initValue = function () {\n      var initValue = props.value;\n      if (decimalValue.value.isInvalidate() && ['string', 'number'].includes(_typeof(initValue))) {\n        return Number.isNaN(initValue) ? '' : initValue;\n      }\n      return mergedFormatter(decimalValue.value.toString(), false);\n    }();\n    inputValue.value = initValue;\n    // Should always be string\n    function setInputValue(newValue, userTyping) {\n      inputValue.value = mergedFormatter(\n      // Invalidate number is sometime passed by external control, we should let it go\n      // Otherwise is controlled by internal interactive logic which check by userTyping\n      // You can ref 'show limited value when input is not focused' test for more info.\n      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);\n    }\n    // >>> Max & Min limit\n    var maxDecimal = computed(function () {\n      return getDecimalIfValidate(props.max);\n    });\n    var minDecimal = computed(function () {\n      return getDecimalIfValidate(props.min);\n    });\n    var upDisabled = computed(function () {\n      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return maxDecimal.value.lessEquals(decimalValue.value);\n    });\n    var downDisabled = computed(function () {\n      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return decimalValue.value.lessEquals(minDecimal.value);\n    });\n    // Cursor controller\n    var _useCursor = useCursor(inputRef, focus),\n      _useCursor2 = _slicedToArray(_useCursor, 2),\n      recordCursor = _useCursor2[0],\n      restoreCursor = _useCursor2[1];\n    // ============================= Data =============================\n    /**\n     * Find target value closet within range.\n     * e.g. [11, 28]:\n     *    3  => 11\n     *    23 => 23\n     *    99 => 28\n     */\n    var getRangeValue = function getRangeValue(target) {\n      // target > max\n      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {\n        return maxDecimal.value;\n      }\n      // target < min\n      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {\n        return minDecimal.value;\n      }\n      return null;\n    };\n    /**\n     * Check value is in [min, max] range\n     */\n    var isInRange = function isInRange(target) {\n      return !getRangeValue(target);\n    };\n    /**\n     * Trigger `onChange` if value validated and not equals of origin.\n     * Return the value that re-align in range.\n     */\n    var triggerValueUpdate = function triggerValueUpdate(newValue, userTyping) {\n      var updateValue = newValue;\n      var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n      // Skip align value when trigger value is empty.\n      // We just trigger onChange(null)\n      // This should not block user typing\n      if (!updateValue.isEmpty() && !userTyping) {\n        // Revert value in range if needed\n        updateValue = getRangeValue(updateValue) || updateValue;\n        isRangeValidate = true;\n      }\n      if (!props.readonly && !props.disabled && isRangeValidate) {\n        var numStr = updateValue.toString();\n        var mergedPrecision = getPrecision(numStr, userTyping);\n        if (mergedPrecision >= 0) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n        }\n        // Trigger event\n        if (!updateValue.equals(decimalValue.value)) {\n          var _props$onChange;\n          setUncontrolledDecimalValue(updateValue);\n          (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, updateValue.isEmpty() ? null : getDecimalValue(props.stringMode, updateValue));\n          // Reformat input if value is not controlled\n          if (props.value === undefined) {\n            setInputValue(updateValue, userTyping);\n          }\n        }\n        return updateValue;\n      }\n      return decimalValue.value;\n    };\n    // ========================== User Input ==========================\n    var onNextPromise = useFrame();\n    // >>> Collect input value\n    var collectInputValue = function collectInputValue(inputStr) {\n      var _props$onInput;\n      recordCursor();\n      // Update inputValue incase input can not parse as number\n      inputValue.value = inputStr;\n      // Parse number\n      if (!compositionRef.value) {\n        var finalValue = mergedParser(inputStr);\n        var finalDecimal = getMiniDecimal(finalValue);\n        if (!finalDecimal.isNaN()) {\n          triggerValueUpdate(finalDecimal, true);\n        }\n      }\n      // Trigger onInput later to let user customize value if they want do handle something after onChange\n      (_props$onInput = props.onInput) === null || _props$onInput === void 0 ? void 0 : _props$onInput.call(props, inputStr);\n      // optimize for chinese input experience\n      // https://github.com/ant-design/ant-design/issues/8196\n      onNextPromise(function () {\n        var nextInputStr = inputStr;\n        if (!props.parser) {\n          nextInputStr = inputStr.replace(/。/g, '.');\n        }\n        if (nextInputStr !== inputStr) {\n          collectInputValue(nextInputStr);\n        }\n      });\n    };\n    // >>> Composition\n    var onCompositionStart = function onCompositionStart() {\n      compositionRef.value = true;\n    };\n    var onCompositionEnd = function onCompositionEnd() {\n      compositionRef.value = false;\n      collectInputValue(inputRef.value.value);\n    };\n    // >>> Input\n    var onInternalInput = function onInternalInput(e) {\n      collectInputValue(e.target.value);\n    };\n    // ============================= Step =============================\n    var onInternalStep = function onInternalStep(up) {\n      var _props$onStep, _inputRef$value;\n      // Ignore step since out of range\n      if (up && upDisabled.value || !up && downDisabled.value) {\n        return;\n      }\n      // Clear typing status since it may caused by up & down key.\n      // We should sync with input value.\n      userTypingRef.value = false;\n      var stepDecimal = getMiniDecimal(props.step);\n      if (!up) {\n        stepDecimal = stepDecimal.negate();\n      }\n      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());\n      var updatedValue = triggerValueUpdate(target, false);\n      (_props$onStep = props.onStep) === null || _props$onStep === void 0 ? void 0 : _props$onStep.call(props, getDecimalValue(props.stringMode, updatedValue), {\n        offset: props.step,\n        type: up ? 'up' : 'down'\n      });\n      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();\n    };\n    // ============================ Flush =============================\n    /**\n     * Flush current input content to trigger value change & re-formatter input if needed\n     */\n    var flushInputValue = function flushInputValue(userTyping) {\n      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      var formatValue = parsedValue;\n      if (!parsedValue.isNaN()) {\n        // Only validate value or empty value can be re-fill to inputValue\n        // Reassign the formatValue within ranged of trigger control\n        formatValue = triggerValueUpdate(parsedValue, userTyping);\n      } else {\n        formatValue = decimalValue.value;\n      }\n      if (props.value !== undefined) {\n        // Reset back with controlled value first\n        setInputValue(decimalValue.value, false);\n      } else if (!formatValue.isNaN()) {\n        // Reset input back since no validate value\n        setInputValue(formatValue, false);\n      }\n    };\n    var onKeyDown = function onKeyDown(event) {\n      var which = event.which;\n      userTypingRef.value = true;\n      if (which === KeyCode.ENTER) {\n        var _props$onPressEnter;\n        if (!compositionRef.value) {\n          userTypingRef.value = false;\n        }\n        flushInputValue(false);\n        (_props$onPressEnter = props.onPressEnter) === null || _props$onPressEnter === void 0 ? void 0 : _props$onPressEnter.call(props, event);\n      }\n      if (props.keyboard === false) {\n        return;\n      }\n      // Do step\n      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {\n        onInternalStep(KeyCode.UP === which);\n        event.preventDefault();\n      }\n    };\n    var onKeyUp = function onKeyUp() {\n      userTypingRef.value = false;\n    };\n    // >>> Focus & Blur\n    var onBlur = function onBlur(e) {\n      flushInputValue(false);\n      focus.value = false;\n      userTypingRef.value = false;\n      emit('blur', e);\n    };\n    // ========================== Controlled ==========================\n    // Input by precision\n    watch(function () {\n      return props.precision;\n    }, function () {\n      if (!decimalValue.value.isInvalidate()) {\n        setInputValue(decimalValue.value, false);\n      }\n    }, {\n      flush: 'post'\n    });\n    // Input by value\n    watch(function () {\n      return props.value;\n    }, function () {\n      var newValue = getMiniDecimal(props.value);\n      decimalValue.value = newValue;\n      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n      // But let it go if user set `formatter`\n      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props.formatter) {\n        // Update value as effect\n        setInputValue(newValue, userTypingRef.value);\n      }\n    }, {\n      flush: 'post'\n    });\n    // ============================ Cursor ============================\n    watch(inputValue, function () {\n      if (props.formatter) {\n        restoreCursor();\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(function () {\n      return props.disabled;\n    }, function (val) {\n      if (val) {\n        focus.value = false;\n      }\n    });\n    expose({\n      focus: function focus() {\n        var _inputRef$value2;\n        (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.focus();\n      },\n      blur: function blur() {\n        var _inputRef$value3;\n        (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.blur();\n      }\n    });\n    return function () {\n      var _classNames;\n      var _attrs$props = _objectSpread(_objectSpread({}, attrs), props),\n        _attrs$props$prefixCl = _attrs$props.prefixCls,\n        prefixCls = _attrs$props$prefixCl === void 0 ? 'rc-input-number' : _attrs$props$prefixCl,\n        min = _attrs$props.min,\n        max = _attrs$props.max,\n        _attrs$props$step = _attrs$props.step,\n        step = _attrs$props$step === void 0 ? 1 : _attrs$props$step,\n        defaultValue = _attrs$props.defaultValue,\n        value = _attrs$props.value,\n        disabled = _attrs$props.disabled,\n        readonly = _attrs$props.readonly,\n        keyboard = _attrs$props.keyboard,\n        _attrs$props$controls = _attrs$props.controls,\n        controls = _attrs$props$controls === void 0 ? true : _attrs$props$controls,\n        autofocus = _attrs$props.autofocus,\n        stringMode = _attrs$props.stringMode,\n        parser = _attrs$props.parser,\n        formatter = _attrs$props.formatter,\n        precision = _attrs$props.precision,\n        decimalSeparator = _attrs$props.decimalSeparator,\n        onChange = _attrs$props.onChange,\n        onInput = _attrs$props.onInput,\n        onPressEnter = _attrs$props.onPressEnter,\n        onStep = _attrs$props.onStep,\n        lazy = _attrs$props.lazy,\n        className = _attrs$props.class,\n        style = _attrs$props.style,\n        inputProps = _objectWithoutProperties(_attrs$props, _excluded);\n      var upHandler = slots.upHandler,\n        downHandler = slots.downHandler;\n      var inputClassName = \"\".concat(prefixCls, \"-input\");\n      var eventProps = {};\n      if (lazy) {\n        eventProps.onChange = onInternalInput;\n      } else {\n        eventProps.onInput = onInternalInput;\n      }\n      return _createVNode(\"div\", {\n        \"class\": classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-focused\"), focus.value), _defineProperty(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefixCls, \"-readonly\"), readonly), _defineProperty(_classNames, \"\".concat(prefixCls, \"-not-a-number\"), decimalValue.value.isNaN()), _defineProperty(_classNames, \"\".concat(prefixCls, \"-out-of-range\"), !decimalValue.value.isInvalidate() && !isInRange(decimalValue.value)), _classNames)),\n        \"style\": style,\n        \"onKeydown\": onKeyDown,\n        \"onKeyup\": onKeyUp\n      }, [controls && _createVNode(StepHandler, {\n        \"prefixCls\": prefixCls,\n        \"upDisabled\": upDisabled.value,\n        \"downDisabled\": downDisabled.value,\n        \"onStep\": onInternalStep\n      }, {\n        upNode: upHandler,\n        downNode: downHandler\n      }), _createVNode(\"div\", {\n        \"class\": \"\".concat(inputClassName, \"-wrap\")\n      }, [_createVNode(\"input\", _objectSpread(_objectSpread(_objectSpread({\n        \"autofocus\": autofocus,\n        \"autocomplete\": \"off\",\n        \"role\": \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),\n        \"step\": step\n      }, inputProps), {}, {\n        \"ref\": inputRef,\n        \"class\": inputClassName,\n        \"value\": inputValue.value,\n        \"disabled\": disabled,\n        \"readonly\": readonly,\n        \"onFocus\": function onFocus(e) {\n          focus.value = true;\n          emit('focus', e);\n        }\n      }, eventProps), {}, {\n        \"onBlur\": onBlur,\n        \"onCompositionstart\": onCompositionStart,\n        \"onCompositionend\": onCompositionEnd\n      }), null)])]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}