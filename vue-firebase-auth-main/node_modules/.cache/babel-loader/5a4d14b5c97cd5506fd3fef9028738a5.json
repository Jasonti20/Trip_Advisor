{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _slots$default;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_defineProperty","_extends","createVNode","_createVNode","defineComponent","ref","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","default","prefixCls","String","onChange","onTestUpdatePosition","Affix","compatConfig","MODE","name","props","setup","_ref","slots","emit","expose","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","targetRect","placeholderReact","fixedTop","fixedBottom","position","top","width","height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_slots$default","className","restProps","_default","call"],"sources":["/Users/jasonti/Desktop/Tripper/vue/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    return function () {\n      var _slots$default;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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"},"metadata":{},"sourceType":"module"}